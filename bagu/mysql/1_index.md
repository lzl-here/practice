# 索引

## 索引比较

- 二叉树 & 红黑树
  树的高度太高了，如果要操作的数据在树的底下，无论增删改查都要经历很多次io
- B树
  一个节点存储自己索引值的行数据，然后在存储子节点的索引值，树的高度相比于只存两个节点降低了很多，增删改查效率要高的多
- B+树
  只有叶子节点存储数据，非叶子节点都只存索引字段，因为一个节点大小就是一页，大小是有限的（默认16kb），相比于B树还需要存具体的行数据，B+树一个非叶子节点下挂载多节点要多很多，所以整棵树更加地矮胖，高度更低，查询数据要经历的磁盘io也要更少
  并且B+树所有的叶子节点都用链表串了起来，进行范围查询也更高效
- 散列表
  散列表对于简单的单个查询开销很低，复杂度为O(n)，但是进行无法进行范围查找，因为散列表上元素存放的位置是随机的
  不支持排序
  不支持部分列查询

## 索引失效

- 对索引字段使用like '%XXX'
- 对索引字段使用了函数、表达式
- 索引字段发生了类型转换
- 索引字段使用in，并且in后面的数据量特别大
- 索引字段使用！=、not between
- 查询使用or，并且一个字段不是索引字段，这样会进行全表扫描：select * from table where id = 1 and age > 18;

## 什么时候适合创建索引？

- 读多写少的时候
- 值域大的字段
- 经常需要where过滤的列
- 需要排序、分组的列
- 需要distinct的列
- 用于连接的列
- 索引覆盖

## 不适合创建索引的的情况？

- 读少写多的时候
- 值域小的字段
- 数据量小

## 什么时候不适合创建索引？

## 常见问题

### 最左匹配原则

指的是建立联合索引时，索引的匹配只能从左向右匹配，假如中间有个字段没有成功走索引，那么后面的字段索引都会失效
对某个字段使用大于号、小于号、like'xxx%'都会导致右边字段索引失效

现有字段 a b c, 根据a b c的顺序建立联合索引

- select * from table where a = 1 and b = 1 and c = 1;  索引成功命中
- select * from table where a = 1 and c > 1;            索引部分命中
- select * from table where b > 1 and c = 1;            索引失效
- select * from table where a > 1 and b = 1 and c = 1;  索引部分失效

建立联合索引时，按照字段顺序排序：先看a的大小，再看b的大小，再看c的大小

同一个a底下的b是有序的，但是不同的a底下的数据合并后不是有序的：
a = 1下面的b： 5, 6, 9
a = 2下面的b： 1, 2, 3
a = 3下面的b:  4, 7, 8

第一个查询语句：
根据a的索引找到1，1底下的b是有序的，再走b的索引，一个b下面的c是有序的，再走c的索引

第二个查询语句：
根据a的索引找到1，2和3各自底下的b是有序的，但是没有b的过滤条件，一堆b下面的c合起来是无序的，只能全部收集然后过滤

第三个查询语句：
没有根据a索引，只能把所有的a下面的b合并起来：5 6 9 1 2 3 5 7 8，这样合并的数据是无序的，所以索引失效

第四个查询语句：
根据a的索引找到2和3，2和3底下的b合并起来是无序的，对于2、3下面的数据就会进行全表扫描

创建联合索引应该将值域大的字段优先放在前面

### 索引覆盖

现有字段 a b c, 根据a b c建立联合索引

现有查询语句：
select * from table where a = 1 and b = 1 and c = 1;
这个索引是非聚簇索引，所以查出id后再进行回表查询，查询出行数据返回

select id, a, b, c from table where a = 1 and b = 1 and c = 1;
所有需要的数据都在索引中，所以不需要回表查询，直接返回结果

### 索引下推

建立联合索引时，在引擎层就可以过滤掉一些数据而不用返回到服务层

现有字段 a b c, 根据a b c建立联合索引

select * from table where a = 1 and b > 1 and c = 1;

没有索引下推：
查询出 a = 1, b > 1的数据，很多c != 1的数据也返回给服务层, 因为>后面的字段不会走索引

有索引下推：
在引擎层过滤掉了c != 1的数据，直接返回正确的数据

## 唯一索引

读：
唯一索引的读效率略高于普通索引，因为读到一个数据就可以直接返回，而普通索引需要继续寻找，但是这点差距几乎没有

写：
普通索引的写入不会立刻写入磁盘，而是写入内存中：change buffer，等后面进行批量写入磁盘
而唯一索引无法利用change buffer，因为得知道磁盘中是否有该数据才能插入，如果有数据的话不应该允许插入，因此不能先写入change buffer后再批量写入
