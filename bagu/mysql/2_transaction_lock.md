# 事务

ACID：
- 原子性: 每个事务中的操作要么都成功，要么都失败，通过**undolog**保证
- 隔离性: 事务之间的互相影响的程度，不同隔离级别之间的事务的隔离性的保证是不一样的，隔离级别越高隔离性越强，由**mvcc和锁**保证
- 持久化: 一旦事务提交了，那么数据就要持久化成功，即使中间发生了宕机也不会丢数据，由**redolog**保证
- 一致性: 前面三点都是为了保证一致性，事务执行时数据库的数据处于不一致状态，只要事务结束数据库的数据就会处于一致状态，比如事务执行前后不会出现某个事物执行一半失败，但是数据保留了下来，或者是事务成功提交但是数据不完整，或者是事务之间读取到了错误的数据导致业务逻辑上出现了错误


## 四大隔离级别

- 读未提交：
不同事物之间可以读取到对方还未提交的数据，通过写时互斥锁解决了更新覆盖的问题

- 读已提交：
一个事务执行中可以读取到别的事务提交后到改变，通过mvcc保证，解决了脏读问题，但是还有不可重复读问题

- 可重复读
一个事务执行中不会读取到别的事务对数据的改变，通过mvcc保证，再配合间隙锁，基本解决幻读问题

- 串行化
给事务上加锁，让事务串行化执行，解决了幻读问题，但是效率极低


## 隔离级别保证的原理

### 读未提交
每个事务都需要解决数据的**脏写问题**：
一行数据a值为0
事务1更新数据a为a+1: 1，此时还未写入磁盘
事务2更新数据a为a+1: 1，写入磁盘
事务1再写入磁盘，最终数据a为1，但是我们执行了两次 a = a + 1，本来应该是2，事务1的更新被事务2覆盖了，这就是脏写问题

解决办法：互斥锁 + 共享锁
事务1在a时加上互斥锁，这样在未写入磁盘前事务2来执行更新操作会阻塞，等待a = 1 写入磁盘后，事务2才能执行更新操作，实现线程安全

事务的加锁时机：
并非事务一开启就获得所有锁，而是执行到具体某一行更新语句才加锁，所以会有死锁问题


### mvcc
mvcc三大法宝：**隐藏字段** + **undolog版本链** + **快照(READVIEW)**
提供多版本并发快照机制，同一时间不同的事物读取到的数据版本不一样
在读已提交级别下，读到的是别的事务提交的版本的快照

#### 隐藏字段
每行数据都有隐藏字段：
- 事务id：每个事务都有一个唯一的id，时间越新id越大
- 数据快照地址：内存中维护了这行数据的多版本链表，记录了不同事物对这行数据的修改逆向操作（undolog实现）

#### 快照
记录了这一瞬间所有活跃的事务id

#### undolog版本链
记录了各个事务修改之前的数据：每个事务修改后，都会向undolog版本链写入旧数据


读已提交下：
一个事务修改一行数据：将自己的事务id写入这行数据的隐藏字段，将undolog写入这行数据的链表中（不是提交事务才写入，而是一修改将写入）
另一个事务来读取这行数据，
1. 生成快照查看，查看事务id是否是自己，如果是返回表里最新数据
2. 不是的话，如果比自己小，并且比快照中最小的事务id还小，说明这个事务早就结束了，返回表里最新数据
3. 如果在活跃事务中，说明这个事务还没结束，返回undolog中的数据
4. 如果比快照中最大的id小，但是不在活跃事务中，说明这个事务结束了，返回表里最新数据
5. 如果比快照中最大的id大，说明生成快照时还没有这个事务，返回undolog中的版本数据

根据快照里的事务信息来判断自己能不能读取到最新的版本的数据，即数据库表里的数据
如果不能就去undolog链表读取比自己老的事务提交的最新的数据


### 读已提交

在**每次select**时生成快照，根据mvcc机制来判断自己能不能读取到最新的数据，如果不能就去undolog链表读取比自己老的事务提交的最新的数据


### 可重复读

事务的第一个**非锁定select语句**，根据mvcc机制来判断自己能不能读取到最新的数据，如果不能就去undolog链表读取比自己老的事务提交的最新的数据
可重复读读到的数据都比较老，在undolog版本链中位置靠后，所以性能更差

可重复度级别下并没有完全解决幻读问题，详情看下面的锁部分

### 串行化

事务的写加互斥锁，读加共享锁，只要涉及到写操作，事务之间就是串行执行，没有读已提交和可重复读的读快照机制，性能最差


## 锁

以下讨论基于InnoDB引擎，MyISAM不包括在内

### 死锁

死锁指两个或以上的线程互相持有对方需要的锁，导致线程互相等待，不通过外力介入将一直僵持下去
MySQL的解决办法：
- 锁超时，事务尝试获取锁时阻塞，超过指定时间自动回滚，回滚时也会释放自己的锁资源，默认50s
- 死锁检测：wait-for-graph: 每个锁都会记录持有自己的事务是谁，每个事务也会记录自己持有什么锁，MySQL会生成一个链表，事务1等待锁a，锁a被事务2持有，链表中事务1就指向事务2，假如事务2指向事务3，而事务3指向事务1，那么链表成环，说明存在互相等待的事务，发生了死锁，那么就会回滚事务1，让事务3继续执行
这个死锁检测是通过参数来控制的，这个操作对性能有影响，默认开启，如果有需要可以关闭

### 行锁

InnoDB的行锁基于聚簇索引上的id锁，而MyISAM没有聚簇索引，叶子中存储的是数据地址，如果根据数据地址上锁，发生数据的删除插入时地址会变，锁住的对象就变了，所以MyISAM只支持表锁，写入性能很差

select 只有在串行化级别才上共享锁

手动上锁(后面再详细说)：
``` sql
-- 共享锁（S锁）：
SELECT * FROM table WHERE user_id = 1 LOCK IN SHARE MODE;
-- 允许其他事务加共享锁，但阻塞排他锁。
-- 适用于需要读取数据并防止其他事务修改的场景（如验证后插入）。
```

``` sql
-- 排他锁（X锁）：
SELECT * FROM table WHERE user_id = 1 FOR UPDATE;
-- 阻塞其他事务的共享锁和排他锁。
-- 适用于需要修改数据前的锁定（如先查后改）。
```


update 语句自带互斥锁, 对于有索引的语句上行锁，对于没有索引的语句上表锁：

``` sql
-- user_id建立了索引，name没有

-- 因为user_id有索引，所以先走索引查到id，再去聚簇索引下找到这个id的记录，对这行记录上锁
update `table` set user_id = 1 where user_id = 1;

-- 因为name没有索引，所以需要全表扫描来找到这个记录，因此需要上表锁，对性能影响非常大，where后面的字段最好要建立索引
update `table` set user_id = 1 where name = 'zhangsan'; 
```

### 间隙锁

mvcc虽然能保证事务读取到自己需要的快照，但是并不能完全保证数据没问题，仍然存在幻读问题：

（以下例子取自：https://juejin.cn/post/7153869469394305061#heading-14）

在可重读级别下

``` sql
SELECT * FROM `zz_users`;
+---------+-----------+----------+----------+---------------------+
| user_id | user_name | user_sex | password | register_time       |
+---------+-----------+----------+----------+---------------------+
|       1 | 熊猫      | 女       | 6666     | 2022-08-14 15:22:01 |
|       2 | 竹子      | 男       | 1234     | 2022-09-14 16:17:44 |
|       3 | 子竹      | 男       | 4321     | 2022-09-16 07:42:21 |
|       4 | 猫熊      | 女       | 8888     | 2022-09-27 17:22:59 |
|       9 | 黑竹      | 男       | 9999     | 2022-09-28 22:31:44 |
+---------+-----------+----------+----------+---------------------+

```
1. 事务2开启
2. 事务1开启，执行：将ID > 3的密码重置为1234
3. 事务2执行：插入ID为6的数据
4. 事务1执行：查询ID > 3的数据，结果为 4 6 9，多了个6，这就是幻读

为什么有了mvcc还会有幻读问题？
mvcc怎么保证能否读取最新版本数据的：
第一次执行select时生成READVIEW，这行数据的事务2的id小于事务1，并且已经提交，在mvcc角度下，这是个已经提交的事务，所以允许读取

那怎么解决幻读问题？在数据的间隙之间上锁：**间隙锁**

### 间隙锁和临键锁

``` sql
-- id为6的数据不存在，给6左右两边的数据中间上锁，6左右分别是4和9，4-9之间上间隙锁，不允许插入数据
select * from `zz_users` where user_id = 6 lock in share mode;
```
