# 异步下单

## 方案：

生产者把消息写入kafka后返回下单成功
消费者从kafka批量读取消息，批量入库，将多个db的写请求聚合成一个来降低db压力

## Q&A

- **为什么需要异步下单？**

1. 因为下单量过大，DB主库写入压力大，需要降低DB的压力
2. 通过kafka的消费者端批量拉取消息，将消息聚合成一批一次写入db，降低db压力

- **怎么保证消息消费的幂等性?**

1. 单纯使用redis是不可靠的，假如消费者读取到消息，写库成功还没来得及ack就宕机，在kafka眼中这条消息还没被消费，服务器重启后会重新拉取，而Redis中的幂等标识已经失效，这样就会重复消费
2. db中有一个记录表，记录订单周期中重要的操作记录，比如下单，发货，收货... 根据这个操作有一个唯一索引，插入时会报错，这样保证强一致性

ps: 因为消息是批量插入的，如果一个订单重复，这一批订单都会报错，所以对唯一索引作特殊判断，假如报了这个错，就查一遍db，过滤掉重复的订单再次执行插入

- **消息消费失败怎么办？**

1. 投递到重试队列中等待再次消费，一直失败的话就告警 + 投入死信队列，死信队列中写db做现场保留
2. 重试队列和死信队列的消费比率要比正式队列慢一些，partition也要少一些，防止影响正常业务

- **为什么不使用canal？**

增加系统复杂度和运维成本，降低系统可用性，假如canal承受不住这么大的流量压力系统也会出问题


- **消费者ack怎么做的？**


## 系统数据
TODO 

