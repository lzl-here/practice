# 


## 消息的可靠性


## 消息的幂等性

at least once
exactly once

exactly once = at least once + 幂等性

1. 流水表，根据业务id + 类型建立唯一索引
2. 版本号，比如msg中带上版本
3. 上游生成唯一token，消息带上token，通过redis/db来判断


## 消息的顺序消费

把需要顺序消费的消息顺序放入一个partition中，一个partition只会被一个消费者消费，这样就完成了顺序消费
不过有可能出现msg1失败，回到partition中，就会排到msg2的后面，者可以通过参数设置

还可以从业务设计角度上来设计，业务上保证状态的正确流转
比如订单：每次推进下一个状态时，都需要判断当前状态是否正确，如果正确则推进下一个状态，否则进行异常处理，通过这种方式来保证数据状态的有序推进

## 消息的积压

设计时的消费者消费能力肯定要高于上游的生产能力，所以积压一般就两种情况:
线上突发流量或者有bug
- 紧急扩容: 扩容消费者同时也要扩容partition，确保消费者和partition1:1
- 降级
- 排查是不是消费端业务逻辑有问题？比如一直异常导致消费失败

 