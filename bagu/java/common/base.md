# 基础

## JavaSE
- 为什么hashcode和equals要同时重写？
    因为往map存放数据时，先根据hashcode计算出放在哪个槽，再遍历链表或者红黑树通过调用双方equals来判断在不在这链表/树里面

- 接口和抽象类的区别？

从我的个人理解上来讲，接口强调行为，目的是解耦，而抽象类强调继承关系，目的是复用

接口：
1. 接口只有抽象方法，变量只能是public static final的
2. 1.8之后可以有静态方法和默认方法
3. 1.9允许有私有方法和静态私有方法
4. 17后sealed来限定哪些类可以实现这个接口
5. 多实现

抽象类：
1. 抽象类可以有任意类型的变量，私有、非静态、非final
2. 可以声明构造函数，并且可以用来约束子类
3. 单继承
4. 17后sealed来限定哪些类可以继承这个抽象类


- 浅拷贝和深拷贝

浅拷贝里面的引用类型对象都是同一个: Object的默认的clone方法，或者实现cloneable重写clone方法
深拷贝里的引用类型对象是不同的对象: 手动递归地复制、序列化、反射

- 自动拆装箱
Integer类中有一个map，存放了缓存的Integer对象，默认-128-127，可以通过jvm参数修改，超过这个范围的会创建新对象 (享元设计模式)

- 泛型
编译期间替我们做类型检查，然后进行泛型擦除


- String、StringBuilder、StringBuffer

String：
不可变的字符串对象: 存放字符串元素的数组是private的，也不对外暴露修改的方法

jvm内部有个字符串池，缓存了很多字符串对象来减少多次创建相同的字符串，减少空间占用以及创建对象的开销
1.8之前存在方法区
1.8之后存在堆空间

StringBuffer：
字符串循环拼接时可以只创建一个String对象
所有方法都通过synchronized上锁，线程安全

StringBuilder：
线程不安全，没有加锁，速度比StringBuffer快

