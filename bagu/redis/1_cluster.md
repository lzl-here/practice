# 集群

## 主从

大部分场景都是读多写少的场景，单台redis可能扛不住这么高的流量，所以需要做读写分离，采用主从架构

主从复制: 
1. 从节点向主节点发送数据同步请求，主节点发现这个请求的id和自己不一样，就返回主节点id和复制进度，然后正式进入复制
2. 第一次复制是全量复制，主节点后台异步生成rdb文件，通过网络请求降rdb发送给从节点 (生成rdb中也会有请求写入主节点，这些请求会写入一个缓冲区，一起同步给从节点)
3. 全量同步后的同步就是增量同步，主节点维护了一个环形缓冲区，里面记录从节点的同步进度和自己当前的写入进度，假如写入进度超过同步进度一圈，再次发生全量同步，发送rdb文件
4. 为了性能考虑，增量同步是异步的，主节点不会等待从节点回复而是直接返回，所以Redis是ap的，并且同步还有个优化：写数据会写入一个缓冲区，进行批量同步

### 主从延迟怎么办?



## 哨兵

从节点宕机倒还好，一般都有多个从节点，立马执行重启就行
但是当主节点发生宕机，那么整个架构都无法写入数据，所以需要引入第三方监控方: sentinel

哨兵是一个独立部署的服务

哨兵集群通过定期向主节点拉取消息，获取集群中每个节点的消息，每个哨兵都和每个Redis节点建立长连接来进行监控

### 主观下线

1. 如果某个哨兵检测到某个节点长时间没有回应，那么认为它主观下线，这时候发起投票询问其他哨兵
2. 超过半数的哨兵也认为这个节点下线那么就认为是客观下线，准备选出新主库
3. 由哪个哨兵来执行主库的选举？这也是需要投票的，一个Raft算法，通过选举投票，一个节点获得半数以上的yes就由它来执行
4. 选举哪个从节点来作为主库？
    1. 长时间没有和哨兵节点连接的从节点不考虑(时间可配置)
    2. 配置文件中韩可以设置优先级，优先级高的优先
    3. 同步进度快的(offset)

客观下线不代表就会发起主从切换，还需要投票出哨兵节点，假如哨兵原来有5个，现在宕机剩下两个，那么无法诞生投票数大于半数(3)的哨兵，所以无法发起主从切换

## 分片集群

单主的架构无法满足高流量的写入时，诞生了分片集群的架构，每个主节点不再拥有全量数据，而是数据的一部分
客户端通过路由到对应的主节点上访问对应的数据，通过这张隔离机制来提高Redis架构的并发量

这种架构下不再需要哨兵，而是节点之间互相存储了其他节点的信息，客户端访问直接访问某个节点，如果数据不在这个节点上，该节点将需要访问的目标节点地址返回给客户端，客户端再次发起访问

TODO 

### 扩容

1. 先将新节点加入集群
2. 确定要迁移的slot，通过redis-trib把数据迁移到新节点上